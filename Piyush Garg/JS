Q What is JS?
JavaScript is a programming language used in web pages to add interactivity and dynamic behavior, beyond just structure (HTML) and style (CSS).

--------------------------------------------------------------------------------------------------------------------------------

- JS is a loosely types language

🔹 Scope of Variables
Q: What is the scope of variables declared with var, let, and const?
var → function-scoped (or globally scoped if declared outside a function).
let & const → block-scoped (accessible only inside { } where declared).
👉 Example:
if (true) {
  var a = 10;
  let b = 20;
}
console.log(a); // 10 ✅
console.log(b); // ReferenceError ❌

🔹 Hoisting
Q: What is hoisting in JavaScript?
Hoisting is JavaScript’s behavior of moving variable and function declarations to the top of their scope before execution.
var → hoisted & initialized as undefined.
let & const → hoisted but not initialized (temporal dead zone).
👉 Example:
console.log(x); // undefined (var hoisted)
var x = 5;

console.log(y); // ReferenceError (TDZ)
let y = 10;

🔹 Difference between var, let, and const
Feature	                    var	                      let	                  const
Scope	                      Function/global	          Block	                Block
Redeclaration              	✅ Allowed	              ❌ Not allowed	      ❌ Not allowed
Reassignment	              ✅ Allowed  	            ✅ Allowed	          ❌ Not allowed
Hoisting	                  Hoisted → undefined	      Hoisted → TDZ	        Hoisted → TDZ
Initialization	            Optional	                Optional	            Mandatory at declaration


--------------------------------------------------------------------------------------------------------------------------------

=> Datatypes in JS: Number, String, Boolean, NULL, Undefined, Objects

- NULL: null is a primitive value in JavaScript that represents the intentional absence of any object value. It means “nothing” or “empty value”.
- Undefined: undefined is a primitive value in JavaScript that means a variable has been declared but not assigned a value yet. It’s the default value given by JavaScript.
- Objects: An object is a collection of key-value pairs (properties). Keys are strings (or symbols), and values can be any data type, including other objects or functions.
let person = {
  name: "Ankita",
  age: 22,
  greet: function() { console.log("Hello!"); }
};

- NaN: NaN stands for “Not-a-Number”. It is a special numeric value that represents a value that cannot be converted to a valid number.

=> typeof operator - give type of a variable
=> Converting a string to Number: '123'*1
whereas 'a'*1 give NaN bcz it is not a valid operation

--------------------------------------------------------------------------------------------------------------------------------

=> arguements in js
arguments is an array-like object available inside every non-arrow function that contains all the arguments passed to that function.
It allows access to all passed parameters, even if the function doesn’t explicitly define them.
Arrow functions do NOT have their own arguments object.

🔹 Example:
function sum() {
  let total = 0;
  for(let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}
console.log(sum(2, 3, 4)); // 9

🔹 Key Points (Interview-friendly)
arguments is array-like, but not a real array (Array.isArray(arguments) → false).
Can be converted to an array:
let args = Array.from(arguments);
Useful when the number of function arguments is unknown.
With ES6, rest parameters (...args) are now preferred over arguments.
function sum(...args) {
  return args.reduce((a,b) => a+b, 0);
}

--------------------------------------------------------------------------------------------------------------------------------

=> ARROW FUNCTIONS: Arrow functions are concise functions that do not have their own this or arguments, and are not hoisted.

1. Syntax:
// Single argument, single expression
const square = x => x * x;
// Multiple arguments
const sum = (a, b) => a + b;
// Multiple statements (needs braces and return)
const sumAndLog = (a, b) => {
  console.log(a, b);
  return a + b;
};

2. Arguments keyword:
Arrow functions do NOT have their own arguments object.
arguments inside an arrow function refers to the enclosing (outer) function’s arguments.
function test() {
  const arrow = () => console.log(arguments);
  arrow();
}
test(1, 2); // logs [1, 2]

- But we can use spread operator
const sumAndLog = (...a) => {
  console.log(a);
};

3. Hoisting
Arrow functions are not hoisted while normal functions are hoisted.
They must be defined before they are called.
console.log(sum(2,3)); // ❌ ReferenceError
const sum = (a,b) => a+b;

4. this keyword
Normal function: this refers to the caller, whereas in an arrow function, it refers to the global window object.
const obj = {
  name: "Ankita",
  arrowFunc: () => console.log(this.name),
  regularFunc: function() { console.log(this.name); }
};

obj.arrowFunc();   // undefined (inherits global this)
obj.regularFunc(); // Ankita

--------------------------------------------------------------------------------------------------------------------------------

=> High Order Function: A higher-order function is a function that takes another function as an argument, returns a function, or both.

🔹 Examples
1. Passing function as argument
function greet(name, formatter) {
  console.log("Hello " + formatter(name));
}

function upperCaseName(name) {
  return name.toUpperCase();
}

greet("Ankita", upperCaseName); // Hello ANKITA
2. Returning a function
function multiplier(factor) {
  return function(number) {
    return number * factor;
  }
}

const double = multiplier(2);
console.log(double(5)); // 10

- Why are they used?

--------------------------------------------------------------------------------------------------------------------------------

🔹 What is an Array in JavaScript?
An array is an ordered collection of values, where each value (element) can be of any data type. Arrays are zero-indexed and are a type of object in JavaScript.
let arr = [1, "hello", true, {name:"Ankita"}];

🔹 Key Points (Interview-friendly)
- Arrays are dynamic: can grow or shrink.
- Elements can be of mixed types.
- Arrays are objects, so typeof arr returns "object".
- Common operations include adding, removing, and iterating elements.

🔹 Common Array Operations

Operation	                        Example
-----------------------------------------------------------------------------
Access element	                  arr[0]
Add element (end)	                arr.push(5)
Remove element (end)	            arr.pop()
Add element (start)	              arr.unshift(0)
Remove element (start)	          arr.shift()
Length	                          arr.length
Iterate	                          arr.forEach(item => console.log(item))
Transform	                        arr.map(x => x*2)
Filter	                          arr.filter(x => x > 2)
Reduce	                          arr.reduce((acc, x) => acc + x, 0)

--------------------------------------------------------------------------------------------------------------------------------

- callback function: A callback function is a function that is passed as an argument to another function, with the intention that it will be executed at a later point in time by the receiving function.

=> forEach:
- forEach is an array method that executes a provided callback function once for each element in an array. It is commonly used for iterating over arrays.
forEach does not return a new array (unlike map).
let numbers = [1, 2, 3];
numbers.forEach((num) => console.log(num));
// Output: 1 2 3

=> map:
map is an array method that creates a new array by applying a callback function to each element of the original array.

const numbers = [1,2,3,4]
function double(n){
  return n*2;
}
const num1 = numbers.forEach(double) // undefined - foreach doesnt return anything it just do some tasks
const num2 = numbers.map(double)     // [2,4,6,8]

=> find:
find is an array method that returns the first element in the array that satisfies the provided testing function (callback). If no element matches, it returns undefined.

const numbers = [1, 2, 3, 4, 5];
const result = numbers.find(num => num > 3);
console.log(result); // 4

=> filter:
filter is an array method that creates a new array containing all elements that satisfy the provided testing function (callback).

const numbers = [1, 2, 3, 4, 5];
const result = numbers.filter(num => num > 3);
console.log(result); // [4, 5]

=> slice:
slice is an array method that returns a shallow copy of a portion of an array into a new array, without modifying the original.
slice creates a shallow copy – primitives are copied by value, but objects inside are copied by reference.

const arr = [10, 20, 30, 40, 50];
arr.slice(1, 3);   // [20, 30]
arr.slice(-2);     // [40, 50]
arr.slice();       // [10, 20, 30, 40, 50] (copy entire array)

=> splice:
splice is an array method used to add, remove, or replace elements in an array. Unlike slice, it modifies the original array.

🔹 Syntax
array.splice(start, deleteCount, item1, item2, ...)
start: index where changes begin.
deleteCount: number of elements to remove.
item1, item2...: elements to add (optional).

🔹 Examples

🟢 1. Delete
arr.splice(start, deleteCount);
👉 Removes deleteCount items starting from start.
Example:
let arr = [1, 2, 3, 4];
arr.splice(1, 2);  // remove 2 elements from index 1
console.log(arr);  // [1, 4]

🟢 2. Add
arr.splice(start, 0, newItem1, newItem2, ...);
👉 If deleteCount = 0, nothing is removed, but new items are inserted at start.
Example:
let arr = [1, 4];
arr.splice(1, 0, 2, 3); // at index 1, remove 0, insert 2 and 3
console.log(arr); // [1, 2, 3, 4]

🟢 3. Replace
arr.splice(start, deleteCount, newItem1, newItem2, ...);
👉 Remove some items and insert new ones at the same place.
Example:
let arr = [1, 2, 3, 4];
arr.splice(1, 2, 99, 100); // from index 1, remove 2 items (2,3) and insert 99,100
console.log(arr); // [1, 99, 100, 4]

🔹 Key Points (Interview-ready)
- Mutates the original array.
- Can be used for insertion, deletion, replacement.
- Returns an array of removed elements.

--------------------------------------------------------------------------------------------------------------------------------

=> DOM: The DOM is a tree-like structure of a webpage, where each HTML element (like <div>, <ul>, <p>) is represented as a node. Using JavaScript, we can access and manipulate these nodes to change the content, style, or structure of the webpage dynamically.
- DOM (Document Object Model) is the way a browser represents a webpage as a tree-like structure.
- Each HTML element (like <p>, <div>) becomes a node in this tree.
- With JavaScript, we can use the DOM to change text, style, or even add/remove elements on the page without reloading it.

=> window:
- window is the global object provided by the browser.
- It represents the browser window/tab that displays the webpage.
- All global variables, functions, and objects like document, console, setTimeout, alert etc. are properties of the window object.
- Interaction with browser is done using window.

--------------------------------------------------------------------------------------------------------------------------------

=> innerHTML and innerText:

🔹 innerHTML
Think: HTML + text inside
It gives you the raw HTML code that’s inside an element.
If you set it, the browser will treat it as HTML.
👉 Example:
<p id="demo"><b>Hello</b></p>
document.getElementById("demo").innerHTML
// Output: "<b>Hello</b>"
If I set:
document.getElementById("demo").innerHTML = "<i>Hi</i>";
It shows Hi in italics.

🔹 innerText
Think: only visible text
It gives you the text that the user actually sees on the screen (ignores tags).
If you set it, the browser treats it as plain text, not HTML.
👉 Example with same code:
document.getElementById("demo").innerText
// Output: "Hello"
If I set:
document.getElementById("demo").innerText = "<i>Hi</i>";
It shows literally <i>Hi</i> (not italic).

=> querySelector and querySelectorAll:

🔹 querySelector()
Returns the first element that matches a CSS selector.
If no match, returns null.
👉 Example:
document.querySelector(".btn");  // first element with class="btn"
document.querySelector("#id");   // element with id="id"
document.querySelector("p");     // first <p> element

🔹 querySelectorAll()
Returns all elements matching the CSS selector.
Result is a NodeList (like an array, but not exactly).
You can loop with forEach, but not use array methods like map directly (unless converted).
👉 Example:
document.querySelectorAll(".btn");  // all elements with class="btn"

=> getELementById, getElementByClass

--------------------------------------------------------------------------------------------------------------------------------

EVENTS:

=> onclick(): 

